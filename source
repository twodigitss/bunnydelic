#!/usr/bin/env python3
#from time import time
from subprocess import run
from os import path, getlogin, environ, popen
from platform import uname
from random import shuffle, choice
from socket import gethostname
from sys import path as SysPath
SysPath.append(f"{path.expanduser('~')}/.config/bunnydelic/"); 
from config import *

#merely for debugging
#timeStart = time()

# functions to fetch information
def get_user(): return getlogin()
def get_host(): return gethostname()
def get_sh(): return environ.get('SHELL')
def get_kern(): return f"{uname().release}"

def get_de(): 
    desktop = environ.get('XDG_CURRENT_DESKTOP')
    session = environ.get('XDG_SESSION_DESKTOP')
    if desktop: return desktop 
    else: return session
    
def get_os():
    return run(
        "grep '^NAME=' /etc/os-release | awk -F '=' '{print $2}' | tr -d '\"'", 
        shell=True, capture_output=True, text=True).stdout.strip()

def get_cpu():
    return run("lscpu | awk '/Model name/ {print $3, $4, $5, $6}'", 
    shell=True, capture_output=True, text=True).stdout.strip()

def get_ram():
    ram = run("free -h | awk '/^Mem/ {print $3, $2}'", 
    shell=True, capture_output=True, text=True).stdout.strip()
    return ram.replace(' ', ' / ').replace('Mi', 'Mb').replace('Gi', 'Gb')

def get_hdw():
    return run("cat /sys/class/dmi/id/product_name", 
    shell=True, capture_output=True, text=True).stdout.strip()

def get_gpu():
    return run(
    "lspci | grep -iE 'VGA|3D|Display' | awk -F '[:[:space:]]+' '{print $6,$7,$8,$9,$10}'", 
    shell=True, capture_output=True, text=True).stdout.strip()

def get_upt(): 
    with open('/proc/uptime', 'r') as file:
        uptime_seconds = int(float(next(file).split()[0]))
        uptime_hours, uptime_minutes = divmod(uptime_seconds // 60, 60)
        return f"{uptime_hours} hours, {uptime_minutes} minutes"

def get_pkg():
    packages=[]
    if path.exists('/etc/pacman.conf'):
        pac=len(popen("pacman -Qq").readlines())
        packages.append(f"{pac} (pacman)")

    elif path.exists('/etc/apt/sources.list') or path.exists('/etc/apt'): 
       apt = run(['dpkg', '-l'], capture_output=True, text=True)
       apt = len(apt.stdout.splitlines()) - 5; #substract header file
       packages.append(f"{apt} (apt)")

    elif path.exists('/etc/dnf/dnf.conf') or path.exists('/etc/yum'): 
       dnf = run(['dnf', 'list', 'installed'], capture_output=True, text=True)
       dnf = len(dnf.stdout.splitlines()) - 1; #substract header file
       packages.append(f"{dnf} (dnf)")

    flatpak = int(run("flatpak list --app --columns=application | wc -l", 
    shell=True, capture_output=True, text=True).stdout.strip()); #flatpak=112
    if flatpak!=0: packages.append(f"{flatpak} (flatpak)")

    return "".join([i+", " if (i!=0 and i!=packages[-1]) else i for i in packages])

#this part of the code was repeated and honestly looks kinda intimidating
def assign_colorblocks():
    global fg_column, info_column
    if color_block_position =="left":
        if not show_phrase:
            if i < len(BGColorList): fg_column=f"{bg[BGColorList[i]]} {fg[FGColorList[i]]}";
            else: fg_column=f'{bg["wht"]} {fg["wht"]}'
        else: #if show_phrase is True
            if i < len(BGColorList)+1: fg_column=f"{bg[BGColorList[i-1]]} {fg[FGColorList[i-1]]}"  
            else: fg_column=f'{bg["wht"]} {fg["wht"]}'
            
    elif color_block_position in ("bottom","off"):
        if not show_phrase: 
            if i < len(BGColorList): fg_column=f"{fg[FGColorList[i]]}" 
            else: fg_column=f'{end}'
        else: #if show_phrase is True
            if i < len(BGColorList)+1: fg_column=f"{fg[FGColorList[i-1]]}" 
            else: fg_column=f'{end}'
            
    else: fg_column=""

styles={ #used to format text (:
    "italic" :  "\033[3m",  "normal":   "", 
    "bold" :    "\033[1m",  "underline":"\033[4m" 
}
colorkeywords={ #used to read vars from config file
    "red":"red", "blue":"ble", "green":"grn", "yellow":"ylw", 
    "purple":"prp", "cyan":"cyn", "white":"wht", "black":"blk"
}
fg={ #normal foreground colors
    "red":  "\033[0;31m",   "grn":  "\033[0;32m",   
    "ylw":  "\033[0;33m",   "ble":  "\033[0;34m",
    "prp":  "\033[0;35m",   "cyn":  "\033[0;36m",
    "wht":  "\033[0;37m",   "blk":  "\033[0;30m",   
}
bg={ #normal background colors that paints a two-spaced square
    "red":"\033[0;41m  \033[0m", "grn":"\033[0;42m  \033[0m",
    "ylw":"\033[0;43m  \033[0m", "ble":"\033[0;44m  \033[0m",
    "prp":"\033[0;45m  \033[0m", "cyn":"\033[0;46m  \033[0m",
    "wht":"\033[0;47m  \033[0m", "blk":"\033[0;40m  \033[0m",
}
faces=[ #feel freee to add more if you want
    "- -", "-_-", "-u-", "-o-", "-w-", "-.-", "-v-", "-~-",
    "'-'", "'·'", "'u'", "'o'", "'w'", "'.'", "'^'", "'~'",
    "O-o", "O_o", "OuO", "O O", "OwO", "O.o", "O^o", "O~o",
    "U-u", "U_u", "U U", "Uou", "Uwu", "U.u", "U^u", "U~u",
    ">-<", ">_<", ">u<", ">o<", ">w<", ">.<", ">^<", ">~<",
    "T-T", "T_T", "TuT", "ToT", "TwT", "T.T", "T^T", "T~T",
    "7-7", "7_7", "7u7", "7o7", "7w7", "7.7", "7^7", "7~7",
    "^-^", "^_^", "^u^", "^o^", "^w^", "^.^", "^ ^", "^~^",
    "·-·", "·_·", "·u·", "·o·", "·w·", "·.·", "·^·", "·~·",
]
distros={ #Robotition suggested this, thank him :>
    "Arch Linux":"",        "Debian GNU/Linux":"",  "EndeavourOS":"",   "Manjaro Linux":"󱘊",     "Parrot":"",
    "Ubuntu":"",            "Pop!_OS":"",           "Fedora Linux":"󰣛",        "Crystal Linux":"",     "Zorin OS":"",
    "Kali GNU/Linux":"",    "Rocky Linux":"",       "Linux Mint":"󰣭",    "AlmaLinux":"",         "MX Linux":"",
    "Archcraft":"",         "ArchLabs":"",          "ArcoLinux":"",     "Artix Linux":"",       "BigLinux":"",
    "CentOS Linux":"",      "Devuan GNU/Linux":"",  "elementary OS":"", "Garuda Linux":"",      "Loc-os":"",
    "Parabola GNU/Linux-libre":"", "Hyperbola GNU/Linux-libre":"",
           
}

#MAIN METHOD
if __name__=="__main__":
    end = "\033[0m"; #escape character to undo previous coloring
    asciiisdefault=True;  #was the default_ascii replaced?

    #colored information style
    phrStyle  = styles.get(phraseStyle)
    colStyle  = styles.get(prefixStyle)
    infoStyle = styles.get(informationStyle)

    if show_phrase is False: phraseToLeft=False
    else: phraseToLeft=True

    #gets desired ascii by index (or "random" if wanted)
    if custom_ascii == "random":
        custom_ascii = choice(ascii_list)
    else: #lets dont forget that custom_ascii also 
        custom_ascii = ascii_list[custom_ascii]

    #sets color block position through parameters to accept random value
    if color_block_position == "random": 
        colBloPosValues = ["off", "left", "bottom"]
        color_block_position = choice(colBloPosValues) 

    #bro, i had a ridiculous functions to sort values to make em equal, just to notice
    #everything was as easy as a value assignation (on variables) to get the same result xDDDDDD
    FGColorList = list(colorkeywords.values())

    if randomize_colors: shuffle(FGColorList)
    else: FGColorList = [colorkeywords[color] for color in static_color_set]

    #match BGColorList with the order set in FGColorList
    BGColorList = FGColorList
    bgblocks="".join([bg[i] for i in BGColorList])

    shuffle(faces)
    c1 = fg[FGColorList[0]];  f1 = faces[0]
    c2 = fg[FGColorList[1]];  f2 = faces[1]
    c3 = fg[FGColorList[2]];  f3 = faces[2]
    c4 = fg[FGColorList[3]];  f4 = faces[3]

    #default ascii art (do not touch pls)
    default_ascii=f'''
(\\ /)    (\\ /)  
( {f1})   ( {f2}) 
c({c1}"{end})({c1}"{end})  c({c2}"{end})({c2}"{end})
                
(\\ /)    (\\ /)  
( {f3})   ( {f4}) 
c({c3}"{end})({c3}"{end})  c({c4}"{end})({c4}"{end})
'''

    if show_ascii == "custom": #if showascii=default: pass
        if custom_ascii: #if customascii has not ascii image on it: pass
            newascii: list = custom_ascii.strip().split('\n')
            max_length = max(len(line) for line in newascii)
            newFormat=[line.ljust(max_length, ' ') for line in newascii]; #!!!
            if phraseToLeft is True: 
                default_ascii = "\n" + '\n'.join(newFormat) + '\n'
            else: 
                default_ascii = "" + '\n'.join(newFormat) + '\n'
            asciiisdefault=False

    # Array with each life of ascii art and a custom auto-adjustable spacer
    ascii_lines= default_ascii.split('\n')
    if asciiisdefault is False: spacer = " " * max(len(line) for line in ascii_lines)
    else: spacer = " " * 16

    #replace stock icon with specific distro icon
    if override_distro_icon is True: #else pass
        your_distro=get_os()
        for item in distros:
            if item==your_distro: icons[0]=distros[item]

    #this is a LIST of every line to print
    info_lines=f'''{phrStyle}{choice(somephrases)}{end}
{icons[0 ]}  {colStyle}Distro:{end}   {infoStyle}{get_os()}{end}
{icons[1 ]}  {colStyle}Owner:{end}    {infoStyle}{get_host()} {get_user()}{end}
{icons[2 ]}  {colStyle}Kernel:{end}   {infoStyle}{get_kern()}{end}
{icons[3 ]}  {colStyle}Desk:{end}     {infoStyle}{get_de()}{end}
{icons[4 ]}  {colStyle}Pkgs:{end}     {infoStyle}{get_pkg()}{end}
{icons[5 ]}  {colStyle}Shell:{end}    {infoStyle}{get_sh()}{end}
{icons[6 ]}  {colStyle}Uptime:{end}   {infoStyle}{get_upt()}{end}
{icons[7 ]}  {colStyle}Ram:{end}      {infoStyle}{get_ram()}{end}
{icons[8 ]}  {colStyle}Cpu:{end}      {infoStyle}{get_cpu()}{end}
{icons[9 ]}  {colStyle}Device:{end}   {infoStyle}{get_hdw()}{end}
{icons[10]}  {colStyle}Graphs:{end}   {infoStyle}{get_gpu()}{end}
{icons[11]}  {colStyle}User:{end}     {infoStyle}{get_user()}{end}
{icons[12]}  {colStyle}Host:{end}     {infoStyle}{get_host()}{end}
'''.split('\n')

    dictOfLines={
        "distro":info_lines[1], "owner":info_lines[2],  "kernel":info_lines[3], 
        "de":info_lines[4],     "pkg":info_lines[5],    "shell":info_lines[6],      
        "uptime":info_lines[7], "ram": info_lines[8],   "cpu":info_lines[9],    
        "gpu": info_lines[11],  "user": info_lines[12], "host": info_lines[13],  
        "model":info_lines[10],
    }

    #Sort the information as "display" variable
    info_lines=info_lines[:1]; #exclude the first line
    for item in display:
        if item in dictOfLines: info_lines.append(dictOfLines[item.lower()])

    #if show_icon is false, removes the first 3 chars of every str 
    if show_icons is False: 
        for i in range(1, len(info_lines)): 
            info_lines[i] = info_lines[i][3:]
        
    if color_block_position == "bottom":
        info_lines=info_lines+[f"{end}"]+[f"{bgblocks}{end}"]

    # what to show if ascii is removed
    if show_ascii == "off":
        #removes the first line, which is the phrase
        info_lines=info_lines[1:] if not show_phrase else info_lines
        max_lines = len(info_lines)+1
        #Starts to process every line
        for i in range(max_lines):
            info_column = info_lines[i]  if i < len(info_lines)  else ''
            #big ass function code i repeated
            assign_colorblocks()

            #this thing does the general processing of every line, the rest was just the color blocks
            if i==0: print(f"{fg_column}{info_column}" if not show_phrase else f"{info_column}")
            else: 
                if not info_column:
                    if   color_block_position in ("left","off"): print(f"")
                    elif color_block_position == "bottom": print(f"{fg_column}{info_column}")
                else: print(f"{fg_column}{info_column}")
    
    # show whatever ascii if no set "off"
    else:
        if show_phrase is False:
            info_lines = info_lines[1:]
            ascii_lines= ascii_lines[1:] if asciiisdefault else ascii_lines
        max_lines = len(ascii_lines) if len(ascii_lines) > len(info_lines) else len(info_lines)+1

        for i in range(max_lines):
            ascii_column  = ascii_lines[i] if i < len(ascii_lines) else spacer
            info_column = info_lines[i]  if i < len(info_lines)  else ''
            #big ass function code i repeated
            assign_colorblocks()
            
            #DO NO forget that this instruction is for printing only the phrase
            if i==0:
                if show_phrase:
                    if asciiisdefault or phraseToLeft: print(f"{ascii_column}{info_column}")
                    else: print(f"{ascii_column}   {info_column}")
                else: print(f"{ascii_column}   {fg_column}{info_column}")
            
            #From here prints the body
            else:
                #if ascii_col stills has something to print
                if ascii_column:
                    if not info_column: #if info_column ended printing
                        if color_block_position in ("left","off"): 
                            print(f"{ascii_column}")
                        elif color_block_position == "bottom": 
                            print(f"{ascii_column}   {fg_column}{info_column}")
                    
                    else: # info_col has more information still
                        print(f"{ascii_column}   {fg_column}{info_column}");# si no hay info el fg si se imprime

                #ascii_col ended printing
                else: 
                    if info_column: print(f"{spacer}   {fg_column}{info_column}")
                    else:
                        if color_block_position in ("left","off"): print(f"{spacer}   ")
                        elif color_block_position == "bottom": print(f"{end}")

    #merely for debugging
    #timeEnd = time()
    #print(f"Execution time: {timeEnd - timeStart}")
    #fastest time: 0.033704519271850586 seconds
